<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bayang-Bayang Qiblat</title>
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" sizes="192x192" href="./icon.png">
  <style>
   body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f7f9fc;
    }

    h2 {
      color: #34495e;
      margin-bottom: 20px;
    }

    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 5px;
      padding: 5px 0;
      position: absolute;
      z-index: 1;
      top: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .tooltip .tooltiptext::after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #555 transparent transparent transparent;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .circle-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin-bottom: 50px;
      background-color: #ffffff;
      border-radius: 50%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .data-inputs {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .circle {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid #2980b9;
      transition: transform 0.5s ease;
      background-color: #ffffff;
    }

    .degree-number {
      position: absolute;
      transform-origin: center;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: #2980b9;
    }

    .center-dot {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: #2980b9;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    }

    .center-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
    }

    .arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: red;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%) rotate(0deg);
      transition: transform 0.5s ease;
    }

    .short-horizontal-line {
      position: absolute;
      width: 250px;
      height: 2px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .vertical-line {
      position: absolute;
      width: 2px;
      height: 250px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
    }

    .label-west, .label-east {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: -20px 0;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north, .label-south {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: 0 5px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north {
      margin-left: -20px;
    }

    .label-south {
      margin-right: -20px;
    }

    .label-east {
      margin-bottom: -20px;
    }

    .label-west {
      margin-top: -20px;
    }

    .arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: red;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
    }

    .black-arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
    }

    .black-arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #333;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
    }

    
    
    .custom-select {
      width: 300px;
      height: 41px;
      padding: 10px;
      font-size: 12px;
      text-align: center;
      margin: 3px 0;
      border: 2px solid #2980b9;
      border-radius: 5px;
      outline: none;
      transition: border-color 0.3s;
      appearance: none;
    }

    select {
      background-color: #ffffff;
      cursor: pointer;
    }

    input[type="number"]::placeholder {
      color: #7f8c8d;
      font-size: 14px;
      opacity: 0.7;
    }

    input[type="number"]:focus, select:focus {
      border-color: #3498db;
    }

    select::-ms-expand {
      display: none;
    }

    #map {
      width: 100%;
      height: 500px;
      margin-top: 20px;
      border: 1px solid #ccc;
    }
    
    #status {
      color: #2980b9;
      font-size: 18px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <br/><br/>
  <div class="container">
    <div class="circle-container">
      <div class="circle" id="circle">
        <div class="center-dot"></div>
        <div class="center-line" id="centerLine"></div>
        <div class="arrow-line" id="arrowLine">
          <div class="arrow-head" id="arrowHead"></div>
        </div>
        <div class="black-arrow-line" id="blackArrowLine">
          <div class="black-arrow-head" id="blackArrowHead"></div>
        </div>
        <div class="short-horizontal-line" id="shortHorizontalLine">
          <div class="label-north">N</div>
          <div class="label-south">S</div>
        </div>
        <div class="vertical-line" id="verticalLine">
          <div class="label-east">E</div>
          <div class="label-west">W</div>
        </div>
      </div>
    </div>

    <div class="data-inputs">
      <select class="custom-select" id="kaedahQiblat">
        <option value="bangunan" selected>Bangunan</option>
        <option value="bayang">Bayang-Bayang</option>
      </select>
      <div class="tooltip">
        <input class="custom-select" type="number" id="degreeInput" placeholder="Bearing" min="0" max="360" step="0.1">
        <span id="degreeTooltip" class="tooltiptext">The angle measured clockwise from true north to a specific point or direction. It helps determine the direction you need to travel or face to reach a location.</span>
      </div>

      <div class="tooltip">
        <input class="custom-select" type="number" id="qiblatInput" placeholder="True North Qiblat" min="0" max="360" step="0.1">
        <span id="qiblatTooltip" class="tooltiptext">The fixed angle that indicates the direction towards the Kaaba in Mecca measure from true north, which Muslims face during prayer. This direction remains constant, allowing people to know where to turn for their prayers no matter where they are.</span>
      </div>
      <div class="tooltip">
        <input class="custom-select" type="datetime-local" id="dateTimeInput" placeholder="Select Date and Time">
        <span id="dateTimeTooltip" class="tooltiptext">Select a specific date and time to calculate the sun's position.</span>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
    function isOnline() {
      return navigator.onLine;
    }

    function loadScript(url, callback) {
      const script = document.createElement('script');
      script.src = url;
      script.onload = callback;
      document.body.appendChild(script);
    }

    let updateBearingAndLines;
    let shadowLine;

    function initializeMapIfOnline() {
      if (isOnline()) {
        const leafletCSS = document.createElement('link');
        leafletCSS.rel = 'stylesheet';
        leafletCSS.href = 'https://unpkg.com/leaflet/dist/leaflet.css';
        document.head.appendChild(leafletCSS);

        const geocoderCSS = document.createElement('link');
        geocoderCSS.rel = 'stylesheet';
        geocoderCSS.href = 'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css';
        document.head.appendChild(geocoderCSS);

        loadScript('https://unpkg.com/leaflet/dist/leaflet.js', function() {
          loadScript('https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js', function() {
            loadScript('https://unpkg.com/suncalc/suncalc.js', initializeMap);
          });
        });
      } else {
        document.getElementById('map').style.display = 'none';
      }
    }

    
    function checkNetworkStatus() {
      if (navigator.onLine) {
        document.getElementById('map').style.display = 'block';
        initializeMapIfOnline();
      }
    }

    window.addEventListener('online', checkNetworkStatus);
    window.addEventListener('offline', checkNetworkStatus);

    checkNetworkStatus();

    function initializeMap() {
      if (!L.Control.Geocoder) {
        console.error('Geocoder library not loaded.');
        return;
      }

      const customIcon = L.icon({
        iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28]
      });

      const map = L.map('map').setView([2.8126, 101.5018], 10);
      
      const esriLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; <a href="https://www.esri.com/">Esri</a>',
        maxZoom: 23
      }).addTo(map);

      const hereSatelliteLayer = L.tileLayer('https://{s}.aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/satellite.day/{z}/{x}/{y}/256/png8?apiKey=xxx&lg=eng', {
        attribution: 'Map data © 2024 HERE',
        subdomains: '1234',
        maxZoom: 22
      });

      const hereNormalDayLayer = L.tileLayer('https://{s}.base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/256/png8?apiKey=xxx&lg=eng', {
        attribution: 'Map data © 2024 HERE',
        subdomains: '1234',
        maxZoom: 20
      });

      const baseMaps = {
        "Esri World Imagery": esriLayer,
        "HERE Satellite": hereSatelliteLayer,
        "HERE Normal Day": hereNormalDayLayer,
      };

      L.control.layers(baseMaps).addTo(map);

      const kaabahLatLng = [21.4225, 39.8262];
      const firstPin = L.marker([2.8126, 101.5018], {icon: customIcon, draggable: true}).addTo(map)
        .bindTooltip('', {permanent: true, direction: 'right'}).openTooltip();

      const secondPin = L.marker([3.1390, 101.6869], {icon: customIcon, draggable: true}).addTo(map)
        .bindTooltip('', {permanent: true, direction: 'right'}).openTooltip();

      map.on('zoomend', function() {
        if (firstPin) {
          map.setView(firstPin.getLatLng(), map.getZoom());
        }
      });

      const initialPath = interpolateGreatCircle(2.8126, 101.5018, kaabahLatLng[0], kaabahLatLng[1], 100);
      const lineToKaabah = L.polyline(initialPath, {color: 'red'}).addTo(map);
      const lineBetweenPins = L.polyline([[2.8126, 101.5018], [3.1390, 101.6869]], {color: 'yellow'}).addTo(map);

      firstPin.on('drag', updateBearingAndLines);
      secondPin.on('drag', updateBearingAndLines);

      map.on('click', function(e) {
        secondPin.setLatLng(e.latlng);
        updateBearingAndLines();
      });

      L.Control.geocoder({
        defaultMarkGeocode: false
      })
      .on('markgeocode', function(e) {
        const bbox = e.geocode.bbox;
        const poly = L.polygon([
            bbox.getSouthEast(),
            bbox.getNorthEast(),
            bbox.getNorthWest(),
            bbox.getSouthWest()
        ]).addTo(map);
        map.fitBounds(poly.getBounds());
        firstPin.setLatLng(e.geocode.center);
        updateBearingAndLines();
      })
      .addTo(map);

      function updateBearingAndLines() {
        if (firstPin && secondPin) {
          const firstLatLng = firstPin.getLatLng();
          const secondLatLng = secondPin.getLatLng();

          const pathToKaabah = interpolateGreatCircle(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1], 100);
          lineToKaabah.setLatLngs(pathToKaabah);

          lineBetweenPins.setLatLngs([firstLatLng, secondLatLng]);

          const bearingToKaabah = calculateBearing(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1]);
          const bearingToSecondPin = calculateBearing(firstLatLng.lat, firstLatLng.lng, secondLatLng.lat, secondLatLng.lng);
          
          const sunAzimuth = updateSunAzimuth(firstLatLng);

          const shadowEndpoint = calculateShadowEndpoint(firstLatLng, sunAzimuth + 180, 10000000);
          if (shadowLine) {
            shadowLine.setLatLngs([firstLatLng, shadowEndpoint]);
          } else {
            shadowLine = L.polyline([firstLatLng, shadowEndpoint], { color: 'grey' }).addTo(map);
          }

          firstPin.setTooltipContent('Qibla: ' + bearingToKaabah.toFixed(2) + '°<br/> Sun Azimuth: ' + sunAzimuth.toFixed(2) + '°');
          secondPin.setTooltipContent('Bearing: ' + bearingToSecondPin.toFixed(2) + '°');

          if (!ELEMENTS.dateTimeInput.value) {
            ELEMENTS.qiblatInput.value = bearingToKaabah.toFixed(2);
          }

          if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
            ELEMENTS.degreeInput.value = bearingToSecondPin.toFixed(2);
          } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
            ELEMENTS.degreeInput.value = sunAzimuth.toFixed(2);
          }

          updateArrow(ELEMENTS.blackArrowLine, sunAzimuth);
          updateArrow(ELEMENTS.blackArrowHead, sunAzimuth);

          updateCompassDisplay();
        }
      };

      function updateSunAzimuth(position) {
        const selectedDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();
        const sunPosition = SunCalc.getPosition(selectedDate, position.lat, position.lng);
        const azimuth = sunPosition.azimuth * 180 / Math.PI + 180;
        return azimuth;
      }

      ELEMENTS.dateTimeInput.addEventListener('change', function() {
        if (typeof updateBearingAndLines === 'function') {
          updateBearingAndLines();
        }
      });
    }

    function calculateShadowEndpoint(startLatLng, azimuth, distance) {
      const earthRadius = 6371000;
      const bearing = toRadians(azimuth);
      
      const lat1 = toRadians(startLatLng.lat);
      const lon1 = toRadians(startLatLng.lng);
      
      const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distance / earthRadius) +
                    Math.cos(lat1) * Math.sin(distance / earthRadius) * Math.cos(bearing));
      const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(distance / earthRadius) * Math.cos(lat1),
                                    Math.cos(distance / earthRadius) - Math.sin(lat1) * Math.sin(lat2));
      
      return L.latLng(toDegrees(lat2), toDegrees(lon2));
    }

    const ELEMENTS = {
      circle: document.getElementById('circle'),
      centerLine: document.getElementById('centerLine'),
      arrowLine: document.getElementById('arrowLine'),
      arrowHead: document.getElementById('arrowHead'),
      blackArrowLine: document.getElementById('blackArrowLine'),
      blackArrowHead: document.getElementById('blackArrowHead'),
      kaedahQiblat: document.getElementById('kaedahQiblat'),
      degreeInput: document.getElementById('degreeInput'),
      degreeTooltip: document.getElementById('degreeTooltip'),
      qiblatInput: document.getElementById('qiblatInput'),
      qiblatTooltip: document.getElementById('qiblatTooltip'),
      distanceToKaabah: document.getElementById('distanceToKaabah'),
      dateTimeInput: document.getElementById('dateTimeInput'),
      status: document.getElementById('status')
    };

    const DISPLAY = {
      BLOCK: 'block',
      NONE: 'none',
    };

    const QIBLAT_METHODS = {
      BANGUNAN: 'bangunan',
      BAYANG: 'bayang',
    };

    function toRadians(degrees) {
      return degrees * Math.PI / 180;
    }

    function toDegrees(radians) {
      return radians * 180 / Math.PI;
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      var lat1Rad = toRadians(lat1);
      var lat2Rad = toRadians(lat2);
      var deltaLonRad = toRadians(lon2 - lon1);

      var y = Math.sin(deltaLonRad) * Math.cos(lat2Rad);
      var x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(deltaLonRad);

      var bearing = Math.atan2(y, x);
      return (toDegrees(bearing) + 360) % 360;
    }

    function interpolateGreatCircle(lat1, lon1, lat2, lon2, steps) {
      var points = [];
      var startLat = toRadians(lat1);
      var startLon = toRadians(lon1);
      var endLat = toRadians(lat2);
      var endLon = toRadians(lon2);

      var d = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((endLat - startLat) / 2), 2) + 
          Math.cos(startLat) * Math.cos(endLat) * Math.pow(Math.sin((endLon - startLon) / 2), 2)));

      for (var i = 0; i <= steps; i++) {
          var f = i / steps;
          var A = Math.sin((1 - f) * d) / Math.sin(d);
          var B = Math.sin(f * d) / Math.sin(d);

          var x = A * Math.cos(startLat) * Math.cos(startLon) + B * Math.cos(endLat) * Math.cos(endLon);
          var y = A * Math.cos(startLat) * Math.sin(startLon) + B * Math.cos(endLat) * Math.sin(endLon);
          var z = A * Math.sin(startLat) + B * Math.sin(endLat);

          var newLat = Math.atan2(z, Math.sqrt(x * x + y * y));
          var newLon = Math.atan2(y, x);

          points.push([toDegrees(newLat), toDegrees(newLon)]);
      }

      return points;
    }

    const showTooltip = (tooltipElement) => {
      tooltipElement.style.visibility = 'visible';
      tooltipElement.style.opacity = '1';
    };

    const hideTooltip = (tooltipElement) => {
      tooltipElement.style.visibility = 'hidden';
      tooltipElement.style.opacity = '0';
    };

    const updateArrow = (element, degree) => {
      element.style.transform = `translateY(-50%) rotate(${degree}deg)`;
    };

    const updateDirectionLabels = () => {
      if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
        document.querySelector('.label-north').textContent = 'S';
        document.querySelector('.label-south').textContent = 'N';
        document.querySelector('.label-east').textContent = 'W';
        document.querySelector('.label-west').textContent = 'E';
      } else {
        document.querySelector('.label-north').textContent = 'N';
        document.querySelector('.label-south').textContent = 'S';
        document.querySelector('.label-east').textContent = 'E';
        document.querySelector('.label-west').textContent = 'W';
      }
    };

    const updateCompassDisplay = () => {
      const degree = parseFloat(ELEMENTS.degreeInput.value) || 0;
      const inputQiblaDegree = parseFloat(ELEMENTS.qiblatInput.value) || 0;

      let finalQiblatDegree = inputQiblaDegree;

      if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
        finalQiblatDegree = (finalQiblatDegree + 180) % 360;
      }

      ELEMENTS.centerLine.style.transform = `translateY(-50%) rotate(${degree}deg)`;
      ELEMENTS.circle.style.transform = `rotate(${90 - degree}deg)`;

      updateArrow(ELEMENTS.blackArrowLine, degree);
      updateArrow(ELEMENTS.blackArrowHead, degree);
      updateArrow(ELEMENTS.arrowLine, finalQiblatDegree || 0);
      updateArrow(ELEMENTS.arrowHead, finalQiblatDegree || 0);
    };

    ELEMENTS.degreeInput.addEventListener('focus', () => {
      showTooltip(ELEMENTS.degreeTooltip);
      setTimeout(() => hideTooltip(ELEMENTS.degreeTooltip), 1000);
    });

    ELEMENTS.degreeInput.addEventListener('blur', () => hideTooltip(ELEMENTS.degreeTooltip));

    ELEMENTS.qiblatInput.addEventListener('focus', () => {
      showTooltip(ELEMENTS.qiblatTooltip);
      setTimeout(() => hideTooltip(ELEMENTS.qiblatTooltip), 1000);
    });

    ELEMENTS.qiblatInput.addEventListener('blur', () => hideTooltip(ELEMENTS.qiblatTooltip));

    const toggleDateTimeInputVisibility = () => {
      if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
        ELEMENTS.dateTimeInput.style.display = DISPLAY.BLOCK;
      } else {
        ELEMENTS.dateTimeInput.style.display = DISPLAY.NONE;
      }
    };

    ELEMENTS.qiblatInput.addEventListener('input', () => {
      updateCompassDisplay();
    });

    ELEMENTS.degreeInput.addEventListener('input', updateCompassDisplay);

    ELEMENTS.kaedahQiblat.addEventListener('change', () => {
      updateDirectionLabels();
      toggleDateTimeInputVisibility();
      if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
        ELEMENTS.degreeInput.placeholder = "Bearing";
        ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
        ELEMENTS.degreeTooltip.textContent = "The angle measured clockwise from true north to a specific point or direction. It helps determine the direction you need to travel or face to reach a location.";
        ELEMENTS.qiblatTooltip.textContent = "The fixed angle that indicates the direction towards the Kaaba in Mecca measure from true north, which Muslims face during prayer. This direction remains constant, allowing people to know where to turn for their prayers no matter where they are.";
      } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
        ELEMENTS.degreeInput.placeholder = "Azimuth Matahari";
        ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
        ELEMENTS.degreeTooltip.textContent = "The angle that shows the sun's position in the sky at a specific time, measured from true north. It helps you know where to look for the sun as it moves from east to west throughout the day.";
        ELEMENTS.qiblatTooltip.textContent = "The fixed angle that indicates the direction towards the Kaaba in Mecca measure from true north, which Muslims face during prayer. This direction remains constant, allowing people to know where to turn for their prayers no matter where they are.";
      }
      updateCompassDisplay();
    });

    const populateDegreeNumbers = () => {
      const radius = ELEMENTS.circle.offsetWidth / 2;
      const offset = 20;
      for (let i = 0; i < 360; i += 10) {
        const degreeNumber = document.createElement('div');
        degreeNumber.className = 'degree-number';
        degreeNumber.textContent = i;

        const angle = i * (Math.PI / 180);
        const x = radius + (radius + offset) * Math.cos(angle);
        const y = radius + (radius + offset) * Math.sin(angle);

        degreeNumber.style.left = `${x}px`;
        degreeNumber.style.top = `${y}px`;
        degreeNumber.style.transform = `translate(-50%, -50%) rotate(${i}deg)`;

        ELEMENTS.circle.appendChild(degreeNumber);
      }
    };

    populateDegreeNumbers();
    updateDirectionLabels();
    toggleDateTimeInputVisibility();

    if (!isOnline()) {
      updateBearingAndLines = function() {
        console.warn("Offline mode: updateBearingAndLines cannot be executed.");
      };
    }

if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js');
    } else {
      alert('ServiceWorker unavailable');
    }
    
    function output(text) {
  document.body.appendChild(new Text(text));
  document.body.appendChild(document.createElement('br'));
}

let cookie = document.cookie.split('; ').filter(value => value.startsWith('time='))[0];
if (!cookie) {
  cookie = `time=${Date.now()}`;
  document.cookie = `${cookie}; max-age=864000`;
}

let strage = localStorage.getItem('time');
if (!strage) localStorage.setItem('time', strage = Date.now());

output(`cookie = ${cookie.split('=')[1]}`);
output(`localStorage = ${strage}`);

// Link to GitHub
{
  const link = document.createElement('a');
  link.href = 'https://github.com/supremindset/pakar';
  link.text = 'A Tag Link';
  document.body.appendChild(link);
  document.body.appendChild(document.createElement('br'));
}

{
  const link = document.createElement('a');
  link.href = 'javascript:void(0)';
  link.onclick = () => {
    location.href = 'https://github.com/supremindset/pakar';
  }
  link.text = 'JavaScript Link';
  document.body.appendChild(link);
  document.body.appendChild(document.createElement('br'));
}

{
  const link = document.createElement('a');
  link.href = 'https://github.com/supremindset/pakar';
  link.target = '_blank';
  link.text = 'New Window Link';
  document.body.appendChild(link);
  document.body.appendChild(document.createElement('br'));
}

  </script>
</body>
</html>
