<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bayang-Bayang Qiblat</title>
  <link rel="canonical" href="https://supremindset.github.io/PAKAR/" />
  <link rel="manifest" href="/PAKAR/manifest.webmanifest">
  <style>
   body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f7f9fc;
    }

    h2 {
      color: #34495e;
      margin-bottom: 20px;
    }

    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 5px;
      padding: 5px 0;
      position: absolute;
      z-index: 1;
      top: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .tooltip .tooltiptext::after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #555 transparent transparent transparent;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .circle-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin-bottom: 50px;
      background-color: #ffffff;
      border-radius: 50%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .data-inputs {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .circle {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid #2980b9;
      transition: transform 0.5s ease;
      background-color: #ffffff;
    }

    .degree-number {
      position: absolute;
      transform-origin: center;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: #2980b9;
    }

    .center-dot {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: #2980b9;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    }

    .center-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
    }

    .arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: red;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%) rotate(0deg);
      transition: transform 0.5s ease;
    }

    .short-horizontal-line {
      position: absolute;
      width: 250px;
      height: 2px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .vertical-line {
      position: absolute;
      width: 2px;
      height: 250px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
    }

    .label-west, .label-east {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: -20px 0;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north, .label-south {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: 0 5px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north {
      margin-left: -20px;
    }

    .label-south {
      margin-right: -20px;
    }

    .label-east {
      margin-bottom: -20px;
    }

    .label-west {
      margin-top: -20px;
    }

    .arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: red;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
    }

    .black-arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
    }

    .black-arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #333;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
    }

    
    
    .custom-select {
      width: 300px;
      height: 41px;
      padding: 10px;
      font-size: 12px;
      text-align: center;
      margin: 3px 0;
      border: 2px solid #2980b9;
      border-radius: 5px;
      outline: none;
      transition: border-color 0.3s;
      appearance: none;
    }

    select {
      background-color: #ffffff;
      cursor: pointer;
    }

    input[type="number"]::placeholder {
      color: #7f8c8d;
      font-size: 14px;
      opacity: 0.7;
    }

    input[type="number"]:focus, select:focus {
      border-color: #3498db;
    }

    select::-ms-expand {
      display: none;
    }

    #map {
      width: 100%;
      height: 500px;
      margin-top: 20px;
      border: 1px solid #ccc;
    }
    
    #status {
      color: #2980b9;
      font-size: 18px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h2 id="distanceToKaabah" placeholder="Distance to Kaaba"></h2>
  <div id="status">Checking network status...</div>
  <br/><br/>
  <div class="container">
    <div class="circle-container">
      <div class="circle" id="circle">
        <div class="center-dot"></div>
        <div class="center-line" id="centerLine"></div>
        <div class="arrow-line" id="arrowLine">
          <div class="arrow-head" id="arrowHead"></div>
        </div>
        <div class="black-arrow-line" id="blackArrowLine">
          <div class="black-arrow-head" id="blackArrowHead"></div>
        </div>
        <div class="short-horizontal-line" id="shortHorizontalLine">
          <div class="label-north">N</div>
          <div class="label-south">S</div>
        </div>
        <div class="vertical-line" id="verticalLine">
          <div class="label-east">E</div>
          <div class="label-west">W</div>
        </div>
      </div>
    </div>

    <div class="data-inputs">
      <select class="custom-select" id="kaedahQiblat">
        <option value="bangunan" selected>Bangunan</option>
        <option value="bayang">Bayang-Bayang</option>
      </select>
      <div class="tooltip">
        <input class="custom-select" type="number" id="degreeInput" placeholder="Bearing" min="0" max="360" step="0.1">
        <span id="degreeTooltip" class="tooltiptext">The angle measured clockwise from true north to a specific point or direction. It helps determine the direction you need to travel or face to reach a location.</span>
      </div>

      <div class="tooltip">
        <input class="custom-select" type="number" id="qiblatInput" placeholder="True North Qiblat" min="0" max="360" step="0.1">
        <span id="qiblatTooltip" class="tooltiptext">The fixed angle that indicates the direction towards the Kaaba in Mecca measure from true north, which Muslims face during prayer. This direction remains constant, allowing people to know where to turn for their prayers no matter where they are.</span>
      </div>
      <!-- Add Date and Time Inputs -->
      <div class="tooltip">
        <input class="custom-select" type="datetime-local" id="dateTimeInput" placeholder="Select Date and Time">
        <span id="dateTimeTooltip" class="tooltiptext">Select a specific date and time to calculate the sun's position.</span>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
  if (navigator.serviceWorker) {
        navigator.serviceWorker.register (
          '/PAKAR/sw.js',
          {scope: '/PAKAR/'}
        )
      }
      
function isOnline() {
  return navigator.onLine;
}

function loadScript(url, callback) {
  const script = document.createElement('script');
  script.src = url;
  script.onload = callback;
  document.body.appendChild(script);
}

let updateBearingAndLines; // Declare the function variable here

// Load scripts and initialize map if online
function initializeMapIfOnline() {
  if (isOnline()) {
    const leafletCSS = document.createElement('link');
    leafletCSS.rel = 'stylesheet';
    leafletCSS.href = 'https://unpkg.com/leaflet/dist/leaflet.css';
    document.head.appendChild(leafletCSS);

    const geocoderCSS = document.createElement('link');
    geocoderCSS.rel = 'stylesheet';
    geocoderCSS.href = 'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css';
    document.head.appendChild(geocoderCSS);

    loadScript('https://unpkg.com/leaflet/dist/leaflet.js', function() {
      loadScript('https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js', function() {
        loadScript('https://unpkg.com/suncalc/suncalc.js', initializeMap);
      });
    });
  } else {
    document.getElementById('map').style.display = 'none';
  }
}

// Pull to Refresh functionality
let startY = 0;
let isPulling = false;

document.body.addEventListener('touchstart', function(e) {
  if (document.body.scrollTop === 0) {
    startY = e.touches[0].pageY;
    isPulling = true;
  }
});

document.body.addEventListener('touchmove', function(e) {
  if (!isPulling) return;
  const currentY = e.touches[0].pageY;
  if (currentY > startY + 50) {
    checkNetworkStatus();
    isPulling = false;
  }
});

document.body.addEventListener('touchend', function() {
  isPulling = false;
});

function checkNetworkStatus() {
  const statusText = document.getElementById('status');
  if (navigator.onLine) {
    statusText.textContent = "You are online.";
    statusText.style.color = "green";
    // Reinitialize the map when coming online
    document.getElementById('map').style.display = 'block'; // Ensure map is visible
    initializeMapIfOnline(); // Call to reinitialize the map
  } else {
    statusText.textContent = "You are offline.";
    statusText.style.color = "red";
    document.getElementById('map').style.display = 'none'; // Hide the map if offline
  }
}

// Initial check
checkNetworkStatus();

function initializeMap() {
  if (!L.Control.Geocoder) {
    console.error('Geocoder library not loaded.');
    return;
  }

  const customIcon = L.icon({
    iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28]
  });

  const map = L.map('map').setView([2.8126, 101.5018], 10);

  const hereSatelliteLayer = L.tileLayer('https://{s}.aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/satellite.day/{z}/{x}/{y}/256/png8?apiKey=xxx&lg=eng', {
    attribution: 'Map data © 2024 HERE',
    subdomains: '1234',
    maxZoom: 22
  }).addTo(map);

  const hereNormalDayLayer = L.tileLayer('https://{s}.base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/256/png8?apiKey=xxx&lg=eng', {
    attribution: 'Map data © 2024 HERE',
    subdomains: '1234',
    maxZoom: 20
  });

  const esriLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles &copy; <a href="https://www.esri.com/">Esri</a>',
    maxZoom: 23
  });

  const baseMaps = {
    "HERE Satellite": hereSatelliteLayer,
    "HERE Normal Day": hereNormalDayLayer,
    "Esri World Imagery": esriLayer
  };

  L.control.layers(baseMaps).addTo(map);

  const kaabahLatLng = [21.4225, 39.8262];
  const firstPin = L.marker([2.8126, 101.5018], {icon: customIcon, draggable: true}).addTo(map)
    .bindTooltip('', {permanent: true, direction: 'right'}).openTooltip();

  const secondPin = L.marker([3.1390, 101.6869], {icon: customIcon, draggable: true}).addTo(map)
    .bindTooltip('', {permanent: true, direction: 'right'}).openTooltip();

  map.on('zoomend', function() {
    if (firstPin) {
      map.setView(firstPin.getLatLng(), map.getZoom());
    }
  });

  const initialPath = interpolateGreatCircle(2.8126, 101.5018, kaabahLatLng[0], kaabahLatLng[1], 100);
  const lineToKaabah = L.polyline(initialPath, {color: 'red'}).addTo(map);
  const lineBetweenPins = L.polyline([[2.8126, 101.5018], [3.1390, 101.6869]], {color: 'yellow'}).addTo(map);

  let shadowLine; // Declare the shadow line variable

  firstPin.on('drag', updateBearingAndLines);
  secondPin.on('drag', updateBearingAndLines);

  map.on('click', function(e) {
    secondPin.setLatLng(e.latlng);
    updateBearingAndLines();
  });

  L.Control.geocoder({
    defaultMarkGeocode: false
  })
  .on('markgeocode', function(e) {
    const bbox = e.geocode.bbox;
    const poly = L.polygon([
        bbox.getSouthEast(),
        bbox.getNorthEast(),
        bbox.getNorthWest(),
        bbox.getSouthWest()
    ]).addTo(map);
    map.fitBounds(poly.getBounds());
    firstPin.setLatLng(e.geocode.center);
    updateBearingAndLines();
  })
  .addTo(map);

  function updateBearingAndLines() {
    if (firstPin && secondPin) {
      const firstLatLng = firstPin.getLatLng();
      const secondLatLng = secondPin.getLatLng();

      const pathToKaabah = interpolateGreatCircle(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1], 100);
      lineToKaabah.setLatLngs(pathToKaabah);

      lineBetweenPins.setLatLngs([firstLatLng, secondLatLng]);

      const bearingToKaabah = calculateBearing(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1]);
      const bearingToSecondPin = calculateBearing(firstLatLng.lat, firstLatLng.lng, secondLatLng.lat, secondLatLng.lng);
      
      // Use the sun azimuth from the dateTimeInput if set, otherwise use the current time
      const sunAzimuth = updateSunAzimuth(firstLatLng, ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date());

      firstPin.setTooltipContent('Qibla: ' + bearingToKaabah.toFixed(2) + '°<br/> Sun Azimuth: ' + sunAzimuth.toFixed(2) + '°');
      secondPin.setTooltipContent('Bearing: ' + bearingToSecondPin.toFixed(2) + '°');

      if (!ELEMENTS.dateTimeInput.value) {
        ELEMENTS.qiblatInput.value = bearingToKaabah.toFixed(2);
      }

      if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
        ELEMENTS.degreeInput.value = bearingToSecondPin.toFixed(2);
      } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
        ELEMENTS.degreeInput.value = sunAzimuth.toFixed(2);
      }

      updateArrow(ELEMENTS.blackArrowLine, sunAzimuth);
      updateArrow(ELEMENTS.blackArrowHead, sunAzimuth);

      updateCompassDisplay();

      // Calculate the shadow endpoint in the opposite direction of the sun's azimuth
      const shadowEndpoint = calculateShadowEndpoint(firstLatLng, sunAzimuth + 180, 10000000); // Add 180 to the azimuth
      if (shadowLine) {
        shadowLine.setLatLngs([firstLatLng, shadowEndpoint]);
      } else {
        shadowLine = L.polyline([firstLatLng, shadowEndpoint], { color: 'grey' }).addTo(map);
      }
    }
  };
}

function updateSunAzimuth(position, date) {
  const sunPosition = SunCalc.getPosition(date, position.lat, position.lng);
  const azimuth = sunPosition.azimuth * 180 / Math.PI + 180;
  return azimuth;
}

function calculateShadowEndpoint(startLatLng, azimuth, distance) {
  const earthRadius = 6371000; // Earth radius in meters
  const bearing = toRadians(azimuth);
  
  const lat1 = toRadians(startLatLng.lat);
  const lon1 = toRadians(startLatLng.lng);
  
  const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distance / earthRadius) +
                Math.cos(lat1) * Math.sin(distance / earthRadius) * Math.cos(bearing));
  const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(distance / earthRadius) * Math.cos(lat1),
                                Math.cos(distance / earthRadius) - Math.sin(lat1) * Math.sin(lat2));
  
  return L.latLng(toDegrees(lat2), toDegrees(lon2));
}

// Element References
const ELEMENTS = {
  circle: document.getElementById('circle'),
  centerLine: document.getElementById('centerLine'),
  arrowLine: document.getElementById('arrowLine'),
  arrowHead: document.getElementById('arrowHead'),
  blackArrowLine: document.getElementById('blackArrowLine'),
  blackArrowHead: document.getElementById('blackArrowHead'),
  kaedahQiblat: document.getElementById('kaedahQiblat'),
  degreeInput: document.getElementById('degreeInput'),
  degreeTooltip: document.getElementById('degreeTooltip'),
  qiblatInput: document.getElementById('qiblatInput'),
  qiblatTooltip: document.getElementById('qiblatTooltip'),
  distanceToKaabah: document.getElementById('distanceToKaabah'),
  dateTimeInput: document.getElementById('dateTimeInput'),
  status: document.getElementById('status')
};

const DISPLAY = {
  BLOCK: 'block',
  NONE: 'none',
};

const QIBLAT_METHODS = {
  BANGUNAN: 'bangunan',
  BAYANG: 'bayang',
};

function toRadians(degrees) {
  return degrees * Math.PI / 180;
}

function toDegrees(radians) {
  return radians * 180 / Math.PI;
}

function calculateBearing(lat1, lon1, lat2, lon2) {
  var lat1Rad = toRadians(lat1);
  var lat2Rad = toRadians(lat2);
  var deltaLonRad = toRadians(lon2 - lon1);

  var y = Math.sin(deltaLonRad) * Math.cos(lat2Rad);
  var x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(deltaLonRad);

  var bearing = Math.atan2(y, x);
  return (toDegrees(bearing) + 360) % 360;
}

function interpolateGreatCircle(lat1, lon1, lat2, lon2, steps) {
  var points = [];
  var startLat = toRadians(lat1);
  var startLon = toRadians(lon1);
  var endLat = toRadians(lat2);
  var endLon = toRadians(lon2);

  var d = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((endLat - startLat) / 2), 2) + 
      Math.cos(startLat) * Math.cos(endLat) * Math.pow(Math.sin((endLon - startLon) / 2), 2)));

  for (var i = 0; i <= steps; i++) {
      var f = i / steps;
      var A = Math.sin((1 - f) * d) / Math.sin(d);
      var B = Math.sin(f * d) / Math.sin(d);

      var x = A * Math.cos(startLat) * Math.cos(startLon) + B * Math.cos(endLat) * Math.cos(endLon);
      var y = A * Math.cos(startLat) * Math.sin(startLon) + B * Math.cos(endLat) * Math.sin(endLon);
      var z = A * Math.sin(startLat) + B * Math.sin(endLat);

      var newLat = Math.atan2(z, Math.sqrt(x * x + y * y));
      var newLon = Math.atan2(y, x);

      points.push([toDegrees(newLat), toDegrees(newLon)]);
  }

  return points;
}

// Tooltip Functions
const showTooltip = (tooltipElement) => {
  tooltipElement.style.visibility = 'visible';
  tooltipElement.style.opacity = '1';
};

const hideTooltip = (tooltipElement) => {
  tooltipElement.style.visibility = 'hidden';
  tooltipElement.style.opacity = '0';
};

// Update Arrow Position
const updateArrow = (element, degree) => {
  element.style.transform = `translateY(-50%) rotate(${degree}deg)`;
};

// Update Direction Labels
const updateDirectionLabels = () => {
  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
    document.querySelector('.label-north').textContent = 'S';
    document.querySelector('.label-south').textContent = 'N';
    document.querySelector('.label-east').textContent = 'W';
    document.querySelector('.label-west').textContent = 'E';
  } else {
    document.querySelector('.label-north').textContent = 'N';
    document.querySelector('.label-south').textContent = 'S';
    document.querySelector('.label-east').textContent = 'E';
    document.querySelector('.label-west').textContent = 'W';
  }
};

// Update Compass Display
const updateCompassDisplay = () => {
  const degree = parseFloat(ELEMENTS.degreeInput.value) || 0;
  const inputQiblaDegree = parseFloat(ELEMENTS.qiblatInput.value) || 0;

  let finalQiblatDegree = inputQiblaDegree;

  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
    finalQiblatDegree = (finalQiblatDegree + 180) % 360;
  }

  ELEMENTS.centerLine.style.transform = `translateY(-50%) rotate(${degree}deg)`;
  ELEMENTS.circle.style.transform = `rotate(${90 - degree}deg)`;

  updateArrow(ELEMENTS.blackArrowLine, degree);
  updateArrow(ELEMENTS.blackArrowHead, degree);
  updateArrow(ELEMENTS.arrowLine, finalQiblatDegree || 0);
  updateArrow(ELEMENTS.arrowHead, finalQiblatDegree || 0);
};

ELEMENTS.degreeInput.addEventListener('focus', () => {
  showTooltip(ELEMENTS.degreeTooltip);
  setTimeout(() => hideTooltip(ELEMENTS.degreeTooltip), 1000);
});

ELEMENTS.degreeInput.addEventListener('blur', () => hideTooltip(ELEMENTS.degreeTooltip));

ELEMENTS.qiblatInput.addEventListener('focus', () => {
  showTooltip(ELEMENTS.qiblatTooltip);
  setTimeout(() => hideTooltip(ELEMENTS.qiblatTooltip), 1000);
});

ELEMENTS.qiblatInput.addEventListener('blur', () => hideTooltip(ELEMENTS.qiblatTooltip));

const toggleDateTimeInputVisibility = () => {
  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
    ELEMENTS.dateTimeInput.style.display = DISPLAY.BLOCK;
  } else {
    ELEMENTS.dateTimeInput.style.display = DISPLAY.NONE;
  }
};

ELEMENTS.qiblatInput.addEventListener('input', () => {
  updateCompassDisplay();
});

ELEMENTS.degreeInput.addEventListener('input', updateCompassDisplay);

ELEMENTS.kaedahQiblat.addEventListener('change', () => {
  updateDirectionLabels();
  toggleDateTimeInputVisibility();
  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
    ELEMENTS.degreeInput.placeholder = "Bearing";
    ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
    ELEMENTS.degreeTooltip.textContent = "The angle measured clockwise from true north to a specific point or direction. It helps determine the direction you need to travel or face to reach a location.";
    ELEMENTS.qiblatTooltip.textContent = "The fixed angle that indicates the direction towards the Kaaba in Mecca measure from true north, which Muslims face during prayer. This direction remains constant, allowing people to know where to turn for their prayers no matter where they are.";
  } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
    ELEMENTS.degreeInput.placeholder = "Azimuth Matahari";
    ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
    ELEMENTS.degreeTooltip.textContent = "The angle that shows the sun's position in the sky at a specific time, measured from true north. It helps you know where to look for the sun as it moves from east to west throughout the day.";
    ELEMENTS.qiblatTooltip.textContent = "The fixed angle that indicates the direction towards the Kaaba in Mecca measure from true north, which Muslims face during prayer. This direction remains constant, allowing people to know where to turn for their prayers no matter where they are.";
  }
  updateCompassDisplay();
});

const populateDegreeNumbers = () => {
  const radius = ELEMENTS.circle.offsetWidth / 2;
  const offset = 20;
  for (let i = 0; i < 360; i += 10) {
    const degreeNumber = document.createElement('div');
    degreeNumber.className = 'degree-number';
    degreeNumber.textContent = i;

    const angle = i * (Math.PI / 180);
    const x = radius + (radius + offset) * Math.cos(angle);
    const y = radius + (radius + offset) * Math.sin(angle);

    degreeNumber.style.left = `${x}px`;
    degreeNumber.style.top = `${y}px`;
    degreeNumber.style.transform = `translate(-50%, -50%) rotate(${i}deg)`;

    ELEMENTS.circle.appendChild(degreeNumber);
  }
};

populateDegreeNumbers();
updateDirectionLabels();
toggleDateTimeInputVisibility();

if (!isOnline()) {
  updateBearingAndLines = function() {
    console.warn("Offline mode: updateBearingAndLines cannot be executed.");
  };
}
</script>
</body>
</html>
