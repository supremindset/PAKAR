<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bayang-Bayang Qiblat</title>
  <link rel="canonical" href="https://supremindset.github.io/PAKAR/" />
  <link rel="manifest" href="/PAKAR/manifest.webmanifest">
  <style>
   body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f7f9fc;
    }

    h2 {
      color: #34495e;
      margin-bottom: 20px;
    }

    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 5px;
      padding: 5px 0;
      position: absolute;
      z-index: 1;
      top: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .tooltip .tooltiptext::after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #555 transparent transparent transparent;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    .container {
      height: 100vh; /* Set a fixed height for the container */
    overflow-y: scroll; /* Enable vertical scrolling */
    width: 100%;
    position: relative;
    padding-top: 30px;
}

    .circle-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin-bottom: 50px;
      background-color: #ffffff;
      border-radius: 50%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }
    
    .sticky-wrapper {
   position: sticky; /* Make the wrapper sticky */
   top: 0; /* Stick to the top of the container or viewport */
   z-index: 1000; /* Ensure it stays on top of other elements */
   width: 100%; /* Ensure it spans the full width */
   display: flex;
   justify-content: center; /* Center the circle-container horizontally */
   background-color: #f7f9fc; /* Match the background color to blend in */
}

    .data-inputs {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .circle {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid #2980b9;
      transition: transform 0.5s ease;
      background-color: #ffffff;
    }

    .degree-number {
      position: absolute;
      transform-origin: center;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: #2980b9;
    }

    .center-dot {
  position: absolute;
  width: 12px;
  height: 12px;
  background-color: #2980b9;
  border-radius: 50%;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
  cursor: pointer; /* Add cursor pointer to indicate it's clickable */
  border: none; /* Remove default button border if using a button element */
  outline: none; /* Remove outline */
}

.center-dot:hover {
  background-color: #3498db; /* Change color on hover */
}

    .center-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
    }

    .arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: red;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%) rotate(0deg);
      transition: transform 0.5s ease;
    }

    .short-horizontal-line {
      position: absolute;
      width: 250px;
      height: 2px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .vertical-line {
      position: absolute;
      width: 2px;
      height: 250px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
    }

    .label-west, .label-east {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: -20px 0;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north, .label-south {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: 0 5px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north {
      margin-left: -20px;
    }

    .label-south {
      margin-right: -20px;
    }

    .label-east {
      margin-bottom: -20px;
    }

    .label-west {
      margin-top: -20px;
    }

    .arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: red;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
    }

    .black-arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
    }

    .black-arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #333;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
    }

    
    
    .custom-select {
      box-sizing: border-box;
    	-webkit-appearance: none;
-moz-appearance: none;
appearance: none;
      width: 300px;
      height: 41px;
      padding: 10px;
      font-size: 12px;
      text-align: center;
      margin: 3px 0;
      border: 2px solid #2980b9;
      border-radius: 5px;
      outline: none;
      transition: border-color 0.3s;
      appearance: none;
    }

    select {
      background-color: #ffffff;
      cursor: pointer;
    }

    input[type="number"]::placeholder {
      color: #7f8c8d;
      font-size: 14px;
      opacity: 0.7;
    }

    input[type="number"]:focus, select:focus {
      border-color: #3498db;
    }

    select::-ms-expand {
      display: none;
    }
    
.all-fieldset {
  border: 2px solid #2980b9;
  border-radius: 5px;
  padding: 10px;
  margin: 20px 0;
  width: 100%;
  box-sizing: border-box;
}

    
    .data-inputs-fieldset {
  border: 2px solid #2980b9;
  border-radius: 5px;
  padding: 10px;
  margin: 10px 0;
}

.location-btn {
  margin-top: 10px;
  padding: 10px 20px;
  background-color: #2980b9;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

.location-btn:hover {
  background-color: #3498db;
}

.map-fieldset {
  border: 2px solid #2980b9;
  border-radius: 5px;
  padding: 10px;
  margin: 20px 0;
  width: 100%;
  box-sizing: border-box;
}

.map-fieldset legend {
  font-size: 1.2em;
  color: #2980b9;
  font-weight: bold;
  padding: 0 10px;
}

    

.angle-label {
    position: absolute;
    top: 60%; /* Move it further down below the red line */
    left: 90%; /* Center it horizontally relative to the line */
    transform: translate(-50%, 0); /* Adjust vertical positioning */
    font-size: 16px;
    color: #333;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}


  </style>
</head>
<body>
  <div class="container">
    <div class="sticky-wrapper">
    <div class="circle-container">
      <div class="circle" id="circle">
  <button class="center-dot" id="centerDotButton"></button>
  <div class="center-line" id="centerLine"></div>
        <div class="arrow-line" id="arrowLine">
       <div class="arrow-head" id="arrowHead"></div>
       <div class="angle-label" id="angleLabel"></div>
   </div>
        <div class="black-arrow-line" id="blackArrowLine">
          <div class="black-arrow-head" id="blackArrowHead"></div>
        </div>
        <div class="short-horizontal-line" id="shortHorizontalLine">
          <div class="label-north">N</div>
          <div class="label-south">S</div>
        </div>
        <div class="vertical-line" id="verticalLine">
          <div class="label-east">E</div>
          <div class="label-west">W</div>
        </div>
      </div>
    </div>
    </div>
    

<fieldset class="data-inputs-fieldset">
    <legend>Qiblat Settings</legend>
    <div class="data-inputs">
  
    <select class="custom-select" id="kaedahQiblat">
      <option value="bangunan" selected>Bangunan</option>
      <option value="bayang">Bayang-Bayang</option>
    </select>
    <div class="tooltip">
      <input class="custom-select" type="number" id="degreeInput" placeholder="Bearing" min="0" max="360" step="0.1">
      <span id="degreeTooltip" class="tooltiptext">The angle measured clockwise from true north to a specific point or direction.</span>
    </div>
    <div class="tooltip">
      <input class="custom-select" type="number" id="qiblatInput" placeholder="True North Qiblat" min="0" max="360" step="0.1">
      <span id="qiblatTooltip" class="tooltiptext">The fixed angle that indicates the direction towards the Kaaba in Mecca measured from true north.</span>
    </div>
    <div class="tooltip">
      <input class="custom-select" type="datetime-local" id="dateTimeInput" placeholder="Select Date and Time">
      <span id="dateTimeTooltip" class="tooltiptext">Select a specific date and time to calculate the sun's position.</span>
    </div>
    </div>
  </fieldset>
  


<fieldset class="map-fieldset">
  <legend><button id="updateLocationButton" class="location-btn">Update Location</button></legend>
  <div id="map" style="position: relative; height: 50vh; width: 100%; margin-top:  0; border: none;">
  </div>
</fieldset>
  </div>
  

<script>
    function isOnline() {
        return navigator.onLine;
    }

    function loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.defer = true; // Ensure script is deferred
        script.onload = callback;
        document.body.appendChild(script);
    }

    let updateBearingAndLines;
    let shadowLine;
    let mapInitialized = false;

    window.onload = function() {
        if (isOnline()) {
            initializeMapIfOnline();
        } else {
            document.getElementById('map').style.display = 'none';
        }
    };

    function initializeMapIfOnline() {
        if (!mapInitialized) {
            loadLeafletResources(function() {
                initializeMap();
                mapInitialized = true;
            });
        }
    }

    function loadLeafletResources(callback) {
        const leafletCSS = document.createElement('link');
        leafletCSS.rel = 'stylesheet';
        leafletCSS.href = 'https://unpkg.com/leaflet/dist/leaflet.css';
        document.head.appendChild(leafletCSS);

        const geocoderCSS = document.createElement('link');
        geocoderCSS.rel = 'stylesheet';
        geocoderCSS.href = 'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css';
        document.head.appendChild(geocoderCSS);

        loadScript('https://unpkg.com/leaflet/dist/leaflet.js', function() {
            loadScript('https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js', function() {
                loadScript('https://unpkg.com/suncalc/suncalc.js', callback);
            });
        });
    }

    function checkNetworkStatus() {
        if (navigator.onLine) {
            document.getElementById('map').style.display = 'block';
            initializeMapIfOnline();
        } else {
            document.getElementById('map').style.display = 'none';
        }
    }

    window.addEventListener('online', checkNetworkStatus);
    window.addEventListener('offline', checkNetworkStatus);

    function initializeMap() {
        if (!L.Control.Geocoder) {
            console.error('Geocoder library not loaded.');
            return;
        }

        const redIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/supremindset/PAKAR/refs/heads/main/redPin.svg',
            iconSize: [100, 100],
            iconAnchor: [30, 100],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28]
        });

        const yellowIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/supremindset/PAKAR/refs/heads/main/yellowPin.svg',
            iconSize: [100, 100],
            iconAnchor: [30, 100],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28]
        });

        const defaultLocation = [2.8126, 101.5018];
        const map = L.map('map').setView(defaultLocation, 10);

        const esriLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; <a href="https://www.esri.com/">Esri</a>',
            maxZoom: 23
        }).addTo(map);

        const hereSatelliteLayer = L.tileLayer('https://{s}.aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/satellite.day/{z}/{x}/{y}/256/png8?apiKey=xxx&lg=eng', {
            attribution: 'Map data © 2024 HERE',
            subdomains: '1234',
            maxZoom: 22
        });

        const hereNormalDayLayer = L.tileLayer('https://{s}.base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/256/png8?apiKey=xxx&lg=eng', {
            attribution: 'Map data © 2024 HERE',
            subdomains: '1234',
            maxZoom: 20
        });

        const openStreetMapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data © OpenStreetMap contributors',
            maxZoom: 19
        });

        const baseMaps = {
            "Esri World Imagery": esriLayer,
            "HERE Satellite": hereSatelliteLayer,
            "HERE Normal Day": hereNormalDayLayer,
            "OpenStreetMap": openStreetMapLayer
        };

        L.control.layers(baseMaps).addTo(map);

        const kaabahLatLng = [21.4225, 39.8262];
        const firstPin = L.marker(defaultLocation, {icon: redIcon, draggable: true}).addTo(map)
            .bindTooltip('', {permanent: true, direction: 'right'}).openTooltip();

        const secondPin = L.marker([3.1390, 101.6869], {icon: yellowIcon, draggable: true}).addTo(map)
            .bindTooltip('', {permanent: true, direction: 'right'}).openTooltip();

        map.on('zoomend', function() {
            if (firstPin) {
                map.setView(firstPin.getLatLng(), map.getZoom());
            }
        });

        const initialPath = interpolateGreatCircle(2.8126, 101.5018, kaabahLatLng[0], kaabahLatLng[1], 100);
        const lineToKaabah = L.polyline(initialPath, {color: 'red'}).addTo(map);
        const lineBetweenPins = L.polyline([[2.8126, 101.5018], [3.1390, 101.6869]], {color: 'yellow'}).addTo(map);

        firstPin.on('drag', function() {
            updateBearingAndLines('firstPin');
        });
        secondPin.on('drag', function() {
            updateBearingAndLines('secondPin');
        });

        map.on('click', function(e) {
            secondPin.setLatLng(e.latlng);
            updateBearingAndLines('secondPin');
        });

        map.on('contextmenu', function(e) {
            firstPin.setLatLng(e.latlng);
            updateBearingAndLines('firstPin');
        });

        L.Control.geocoder({
            defaultMarkGeocode: false
        })
        .on('markgeocode', function(e) {
            const bbox = e.geocode.bbox;
            const poly = L.polygon([
                bbox.getSouthEast(),
                bbox.getNorthEast(),
                bbox.getNorthWest(),
                bbox.getSouthWest()
            ]).addTo(map);
            map.fitBounds(poly.getBounds());
            firstPin.setLatLng(e.geocode.center);
            updateBearingAndLines('firstPin');
        })
        .addTo(map);

        function updateLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        const userLat = position.coords.latitude;
                        const userLng = position.coords.longitude;
                        map.setView([userLat, userLng], 13);
                        firstPin.setLatLng([userLat, userLng]);
                        updateBearingAndLines('firstPin');
                    },
                    function() {
                        console.error('Geolocation permission denied or unavailable. Defaulting to Banting, Selangor.');
                        alert('Unable to retrieve your location. Please enable location services.');
                        map.setView(defaultLocation, 13);
                        firstPin.setLatLng(defaultLocation);
                        updateBearingAndLines('firstPin');
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                );
            } else {
                console.error('Geolocation is not supported by this browser. Defaulting to Banting, Selangor.');
                map.setView(defaultLocation, 13);
                firstPin.setLatLng(defaultLocation);
                updateBearingAndLines('firstPin');
            }
        }

        const updateLocationButton = document.getElementById('updateLocationButton');
        updateLocationButton.addEventListener('click', updateLocation);

        const centerDotButton = document.getElementById('centerDotButton');
        centerDotButton.addEventListener('click', updateLocation);

        updateBearingAndLines = function(changedPin) {
            if (firstPin && secondPin) {
                const firstLatLng = firstPin.getLatLng();
                const secondLatLng = secondPin.getLatLng();

                const pathToKaabah = interpolateGreatCircle(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1], 100);
                lineToKaabah.setLatLngs(pathToKaabah);

                lineBetweenPins.setLatLngs([firstLatLng, secondLatLng]);

                const bearingToKaabah = calculateBearing(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1]);
                const bearingToSecondPin = calculateBearing(firstLatLng.lat, firstLatLng.lng, secondLatLng.lat, secondLatLng.lng);
                
                let sunAzimuth;
                if (changedPin === 'firstPin') {
                    sunAzimuth = updateSunAzimuth(firstLatLng);
                } else {
                    sunAzimuth = parseFloat(ELEMENTS.degreeInput.value) || 0;
                }

                const shadowEndpoint = calculateShadowEndpoint(firstLatLng, 1000000);
                if (shadowLine) {
                    shadowLine.setLatLngs([firstLatLng, shadowEndpoint]);
                } else {
                    shadowLine = L.polyline([firstLatLng, shadowEndpoint], { color: 'grey' }).addTo(map);
                }

                firstPin.setTooltipContent('Qibla: ' + bearingToKaabah.toFixed(2) + '°<br/> Sun Azimuth: ' + sunAzimuth.toFixed(2) + '°');
                secondPin.setTooltipContent('Bearing: ' + bearingToSecondPin.toFixed(2) + '°');

                if (!ELEMENTS.dateTimeInput.value) {
                    ELEMENTS.qiblatInput.value = bearingToKaabah.toFixed(2);
                }

                if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
                    ELEMENTS.degreeInput.value = bearingToSecondPin.toFixed(2);
                } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
                    ELEMENTS.degreeInput.value = sunAzimuth.toFixed(2);
                }

                updateArrow(ELEMENTS.blackArrowLine, sunAzimuth);
                updateArrow(ELEMENTS.blackArrowHead, sunAzimuth);

                updateCompassDisplay();
            }
        };

        function updateSunAzimuth(position) {
            const selectedDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();
            const sunPosition = SunCalc.getPosition(selectedDate, position.lat, position.lng);
            const azimuth = sunPosition.azimuth * 180 / Math.PI + 180;
            return azimuth;
        }

        ELEMENTS.dateTimeInput.addEventListener('change', function() {
            if (typeof updateBearingAndLines === 'function') {
                updateBearingAndLines('firstPin');
            }
        });

        ELEMENTS.kaedahQiblat.addEventListener('change', () => {
            updateDirectionLabels();
            toggleDateTimeInputVisibility();
            updateBearingAndLines('firstPin');
            if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
                ELEMENTS.degreeInput.placeholder = "Bearing";
                ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
                ELEMENTS.degreeTooltip.textContent = "The angle measured clockwise from true north to a specific point or direction.";
                ELEMENTS.qiblatTooltip.textContent = "The fixed angle that indicates the direction towards the Kaaba in Mecca measure from true north.";
            } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
                ELEMENTS.degreeInput.placeholder = "Azimuth Matahari";
                ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
                ELEMENTS.degreeTooltip.textContent = "The angle that shows the sun's position in the sky at a specific time, measured from true north.";
                ELEMENTS.qiblatTooltip.textContent = "The fixed angle that indicates the direction towards the Kaaba in Mecca measure from true north.";
            }
            updateCompassDisplay();
        });
    }

    function calculateShadowEndpoint(startLatLng, objectHeight) {
        const selectedDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();
        const position = SunCalc.getPosition(selectedDate, startLatLng.lat, startLatLng.lng);

        const azimuth = position.azimuth;
        const altitude = position.altitude;

        const shadowLength = objectHeight / Math.tan(altitude);

        const earthRadius = 6371000;

        const angularDistance = shadowLength / earthRadius;
        const bearing = azimuth;

        const lat1 = toRadians(startLatLng.lat);
        const lon1 = toRadians(startLatLng.lng);

        const lat2 = Math.asin(Math.sin(lat1) * Math.cos(angularDistance) +
            Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(bearing));
        const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(lat1),
            Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(lat2));

        return L.latLng(toDegrees(lat2), toDegrees(lon2));
    }

    const ELEMENTS = {
        circle: document.getElementById('circle'),
        centerLine: document.getElementById('centerLine'),
        arrowLine: document.getElementById('arrowLine'),
        arrowHead: document.getElementById('arrowHead'),
        blackArrowLine: document.getElementById('blackArrowLine'),
        blackArrowHead: document.getElementById('blackArrowHead'),
        kaedahQiblat: document.getElementById('kaedahQiblat'),
        degreeInput: document.getElementById('degreeInput'),
        degreeTooltip: document.getElementById('degreeTooltip'),
        qiblatInput: document.getElementById('qiblatInput'),
        qiblatTooltip: document.getElementById('qiblatTooltip'),
        distanceToKaabah: document.getElementById('distanceToKaabah'),
        dateTimeInput: document.getElementById('dateTimeInput'),
        status: document.getElementById('status')
    };

    const DISPLAY = {
        BLOCK: 'block',
        NONE: 'none',
    };

    const QIBLAT_METHODS = {
        BANGUNAN: 'bangunan',
        BAYANG: 'bayang',
    };

    function toRadians(degrees) {
        return degrees * Math.PI / 180;
    }

    function toDegrees(radians) {
        return radians * 180 / Math.PI;
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
        var lat1Rad = toRadians(lat1);
        var lat2Rad = toRadians(lat2);
        var deltaLonRad = toRadians(lon2 - lon1);

        var y = Math.sin(deltaLonRad) * Math.cos(lat2Rad);
        var x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(deltaLonRad);

        var bearing = Math.atan2(y, x);
        return (toDegrees(bearing) + 360) % 360;
    }

    function interpolateGreatCircle(lat1, lon1, lat2, lon2, steps) {
        var points = [];
        var startLat = toRadians(lat1);
        var startLon = toRadians(lon1);
        var endLat = toRadians(lat2);
        var endLon = toRadians(lon2);

        var d = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((endLat - startLat) / 2), 2) +
            Math.cos(startLat) * Math.cos(endLat) * Math.pow(Math.sin((endLon - startLon) / 2), 2)));

        for (var i = 0; i <= steps; i++) {
            var f = i / steps;
            var A = Math.sin((1 - f) * d) / Math.sin(d);
            var B = Math.sin(f * d) / Math.sin(d);

            var x = A * Math.cos(startLat) * Math.cos(startLon) + B * Math.cos(endLat) * Math.cos(endLon);
            var y = A * Math.cos(startLat) * Math.sin(startLon) + B * Math.cos(endLat) * Math.sin(endLon);
            var z = A * Math.sin(startLat) + B * Math.sin(endLat);

            var newLat = Math.atan2(z, Math.sqrt(x * x + y * y));
            var newLon = Math.atan2(y, x);

            points.push([toDegrees(newLat), toDegrees(newLon)]);
        }

        return points;
    }

    const showTooltip = (tooltipElement) => {
        tooltipElement.style.visibility = 'visible';
        tooltipElement.style.opacity = '1';
    };

    const hideTooltip = (tooltipElement) => {
        tooltipElement.style.visibility = 'hidden';
        tooltipElement.style.opacity = '0';
    };

    const updateArrow = (element, degree) => {
        element.style.transform = `translateY(-50%) rotate(${degree}deg)`;
    };

    const updateDirectionLabels = () => {
        if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
            document.querySelector('.label-north').textContent = 'S';
            document.querySelector('.label-south').textContent = 'N';
            document.querySelector('.label-east').textContent = 'W';
            document.querySelector('.label-west').textContent = 'E';
        } else {
            document.querySelector('.label-north').textContent = 'N';
            document.querySelector('.label-south').textContent = 'S';
            document.querySelector('.label-east').textContent = 'E';
            document.querySelector('.label-west').textContent = 'W';
        }
    };

    const updateCompassDisplay = () => {
        const degree = parseFloat(ELEMENTS.degreeInput.value) || 0;
        const inputQiblaDegree = parseFloat(ELEMENTS.qiblatInput.value) || 0;

        let finalQiblatDegree = inputQiblaDegree;

        if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
            finalQiblatDegree = (finalQiblatDegree + 180) % 360;
        }

        ELEMENTS.centerLine.style.transform = `translateY(-50%) rotate(${degree}deg)`;
        ELEMENTS.circle.style.transform = `rotate(${90 - degree}deg)`;

        updateArrow(ELEMENTS.blackArrowLine, degree);
        updateArrow(ELEMENTS.blackArrowHead, degree);
        updateArrow(ELEMENTS.arrowLine, finalQiblatDegree || 0);
        updateArrow(ELEMENTS.arrowHead, finalQiblatDegree || 0);

        const angleBetweenLines = calculateAngleBetweenLines(degree, finalQiblatDegree);
        ELEMENTS.angleLabel.textContent = `${angleBetweenLines.toFixed(2)}°`;
    };

    function calculateAngleBetweenLines(degree1, degree2) {
        let angle = Math.abs(degree2 - degree1);
        if (angle > 180) {
            angle = 360 - angle;
        }
        return angle;
    }

    ELEMENTS.degreeInput.addEventListener('focus', () => {
        showTooltip(ELEMENTS.degreeTooltip);
        setTimeout(() => hideTooltip(ELEMENTS.degreeTooltip), 1000);
    });

    ELEMENTS.degreeInput.addEventListener('blur', () => hideTooltip(ELEMENTS.degreeTooltip));

    ELEMENTS.qiblatInput.addEventListener('focus', () => {
        showTooltip(ELEMENTS.qiblatTooltip);
        setTimeout(() => hideTooltip(ELEMENTS.qiblatTooltip), 1000);
    });

    ELEMENTS.qiblatInput.addEventListener('blur', () => hideTooltip(ELEMENTS.qiblatTooltip));

    const toggleDateTimeInputVisibility = () => {
        if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
            ELEMENTS.dateTimeInput.style.display = DISPLAY.BLOCK;
        } else {
            ELEMENTS.dateTimeInput.style.display = DISPLAY.NONE;
        }
    };

    ELEMENTS.qiblatInput.addEventListener('input', () => {
        updateCompassDisplay();
    });

    ELEMENTS.degreeInput.addEventListener('input', updateCompassDisplay);

    const populateDegreeNumbers = () => {
        const radius = ELEMENTS.circle.offsetWidth / 2;
        const offset = 20;
        for (let i = 0; i < 360; i += 10) {
            const degreeNumber = document.createElement('div');
            degreeNumber.className = 'degree-number';
            degreeNumber.textContent = i;

            const angle = i * (Math.PI / 180);
            const x = radius + (radius + offset) * Math.cos(angle);
            const y = radius + (radius + offset) * Math.sin(angle);

            degreeNumber.style.left = `${x}px`;
            degreeNumber.style.top = `${y}px`;
            degreeNumber.style.transform = `translate(-50%, -50%) rotate(${i}deg)`;

            ELEMENTS.circle.appendChild(degreeNumber);
        }
    };

    function createAngleLabel() {
        const angleLabel = document.createElement('div');
        angleLabel.className = 'angle-label';
        ELEMENTS.arrowLine.appendChild(angleLabel);
        ELEMENTS.angleLabel = angleLabel;
    }

    populateDegreeNumbers();
    updateDirectionLabels();
    toggleDateTimeInputVisibility();
    createAngleLabel();

    if (!isOnline()) {
        updateBearingAndLines = function() {
            console.warn("Offline mode: updateBearingAndLines cannot be executed.");
        };
    }
</script>
<script>
  if (navigator.serviceWorker) {
    navigator.serviceWorker.register (
      '/PAKAR/sw.js',
      {scope: '/PAKAR/'}
    )
  }
  </script>
</body>
</html>