<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bayang-Bayang Qiblat</title>
  <link rel="canonical" href="https://supremindset.github.io/PAKAR/" />
  <link rel="manifest" href="/PAKAR/manifest.json">
  <script>
    if (navigator.serviceWorker) {
      navigator.serviceWorker.register(
        '/PAKAR/sw.js',
        {scope: '/PAKAR/'}
      )
    }
    
  </script>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f7f9fc;
    }

    h2 {
      color: #34495e;
      margin-bottom: 20px;
    }

    .container {
      height: auto;
      min-height: 100vh;
      overflow-y: auto; /* Ensure the container can scroll */
      width: 100%;
      position: relative;
      padding-top: 30px;
    }

    .circle-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin-bottom: 50px;
      background-color: #ffffff;
      border-radius: 50%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      z-index: 1;
    }
    
    .sticky-wrapper {
      position: sticky;
      top: 0;
      z-index: 1000;
      width: 100%;
      display: flex;
      justify-content: center;
      background-color: #f7f9fc;
    }

    .non-sticky {
      position: static; /* Changes from sticky to static */
    }

    .data-inputs {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px; /* Add some margin to prevent overlap with other elements */
    }

    .circle {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid #2980b9;
      transition: transform 0.5s ease;
      background-color: #ffffff;
      z-index: 1; /* Base z-index for the circle */
    }
    
    .degree-number {
      position: absolute;
      transform-origin: center;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: #2980b9;
    }

    .center-dot {
      position: absolute;
      width: 30px;
      height: 30px;
      background-color: #2980b9;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      border: 2px solid #ffffff;
      transition: background-color 0.3s, transform 0.3s, box-shadow 0.3s;
      z-index: 3; /* Higher z-index to place it on top of lines */
    }

    .center-dot:hover {
      background-color: #3498db;
      transform: translate(-50%, -50%) scale(1.1);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.3), 0 6px 12px rgba(0, 0, 0, 0.3);
    }

    .center-dot:active {
      background-color: #1e6a8d;
      transform: translate(-50%, -50%) scale(0.95);
    }

    .center-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure lines are behind the center-dot */
    }

    .arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: red;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%) rotate(0deg);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure lines are behind the center-dot */
    }

    .short-horizontal-line {
      position: absolute;
      width: 250px;
      height: 2px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .vertical-line {
      position: absolute;
      width: 2px;
      height: 250px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
    }

    .label-west, .label-east {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: -20px 0;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north, .label-south {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: 0 5px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north {
      margin-left: -20px;
    }

    .label-south {
      margin-right: -20px;
    }

    .label-east {
      margin-bottom: -20px;
    }

    .label-west {
      margin-top: -20px;
    }

    .arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: red;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure heads are behind the center-dot */
    }

    .black-arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure lines are behind the center-dot */
    }

    .black-arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #333;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure heads are behind the center-dot */
    }

    .custom-select {
      box-sizing: border-box;
      width: 300px;
      height: 41px;
      padding: 10px;
      font-size: 14px;
      text-align: center;
      margin: 5px 0; /* Slightly larger margin for better spacing */
      border: 2px solid #2980b9;
      border-radius: 5px;
      outline: none;
      transition: border-color 0.3s;
      background-color: #ffffff;
      cursor: pointer;
    }

    select {
      background-color: #ffffff;
      cursor: pointer;
    }

    input[type="number"]::placeholder {
      color: #7f8c8d;
      font-size: 14px;
      opacity: 0.7;
    }

    input[type="number"]:focus, select:focus {
      border-color: #3498db;
    }

    select::-ms-expand {
      display: none;
    }
    
    .all-fieldset {
      border: 2px solid #2980b9;
      border-radius: 5px;
      padding: 10px;
      margin: 20px 0;
      width: 100%;
      box-sizing: border-box;
    }

    .data-inputs-fieldset {
      border: 2px solid #2980b9;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
    }

    .location-btn {
      margin-top: 10px;
      padding: 10px 20px;
      background-color: #2980b9;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    .location-btn:hover {
      background-color: #3498db;
    }

    .map-fieldset {
      border: 2px solid #2980b9;
      border-radius: 5px;
      padding: 10px;
      margin: 20px 0;
      width: 100%;
      box-sizing: border-box;
    }

    .map-fieldset legend {
      font-size: 1.2em;
      color: #2980b9;
      font-weight: bold;
      padding: 0 10px;
    }

    .angle-label {
      position: absolute;
      top: 60%; /* Move it further down below the red line */
      left: 90%; /* Center it horizontally relative to the line */
      transform: translate(-50%, 0); /* Adjust vertical positioning */
      font-size: 16px;
      color: #333;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    #map.circle-map {
      border-radius: 50%; /* Ensure circular shape */
      overflow: hidden; /* Hide overflow */
      transition: all 0.3s ease; /* Smooth transition for resizing */
    }

    #map {
      position: relative;
      height: 50vh;
      width: 100%;
      margin-top: 0;
      border: none;
      transition: all 0.3s ease; /* Smooth transition */
      z-index: 8;
    }

    .slider-container {
      width: 300px;
      margin: 20px auto;
      text-align: center;
    }

    input[type="range"] {
      width: 100%;
      margin: 10px 0;
    }

    .leaflet-control {
      top: 100px;
    }
    
    .red-text {
  color: #1e6a8d;
}

.yellow-text {
  color: #1e6a8d;
}
  </style>
</head>
<body>
  <div class="container">
    <div class="sticky-wrapper">
      <div class="circle-container">
        <div class="circle" id="circle">
          <button class="center-dot" id="centerDotButton"></button>
          <div class="center-line" id="centerLine"></div>
          <div class="arrow-line" id="arrowLine">
            <div class="arrow-head" id="arrowHead"></div>
            <div class="angle-label" id="angleLabel"></div>
          </div>
          <div class="black-arrow-line" id="blackArrowLine">
            <div class="black-arrow-head" id="blackArrowHead"></div>
          </div>
          <div class="short-horizontal-line" id="shortHorizontalLine">
            <div class="label-north">N</div>
            <div class="label-south">S</div>
          </div>
          <div class="vertical-line" id="verticalLine">
            <div class="label-east">E</div>
            <div class="label-west">W</div>
          </div>
        </div>
      </div>
    </div>
    
    <div id="install-banner-container"></div>
    
    <fieldset class="map-fieldset">
      <legend><button id="updateLocationButton" class="location-btn">Update Location</button></legend>
      <div id="map" style="position: relative; height: 50vh; width: 100%; margin-top: 0; border: none;"></div>
    </fieldset>

    <div id="markerTooltipContainer" style="padding: 10px; background-color: #f7f9fc; border-top: 1px solid #2980b9;">
  <p>
    <span class="red-text" id="markerTooltipText1"></span>
    <span class="yellow-text" id="markerTooltipText2"></span>
  </p>
</div>

    <fieldset class="data-inputs-fieldset">
      <legend>Qiblat Settings</legend>
      <div class="data-inputs">
        <button id="toggleMapCircle" class="location-btn">Fit Map to Circle</button>
        <select class="custom-select" id="kaedahQiblat">
          <option value="bangunan" selected>Bangunan</option>
          <option value="bayang">Bayang-Bayang</option>
        </select>
        
          <input class="custom-select" type="number" id="degreeInput" placeholder="Bearing" min="0" max="360" step="0.1">
          
        
          <input class="custom-select" type="number" id="qiblatInput" placeholder="True North Qiblat" min="0" max="360" step="0.1">
          
        
        
          <input class="custom-select" type="datetime-local" id="dateTimeInput" placeholder="Select Date and Time">
          
      </div>
      <div class="slider-container">
        <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0">
        <label for="rotationSlider" id="rotationValue">0°</label>
      </div>
    </fieldset>
  </div>
  <script>
    function isOnline() {
  return navigator.onLine;
}

function loadScript(url, callback) {
  const script = document.createElement('script');
  script.src = url;
  script.defer = true; // Ensure script is deferred
  script.onload = callback;
  document.body.appendChild(script);
}

let updateBearingAndLines;
let shadowLine;
let mapInitialized = false;
let activityTimeout; // Variable to store the timeout ID

window.onload = function() {
  if (isOnline()) {
    initializeMapIfOnline();
  } else {
    document.getElementById('map').style.display = 'none';
  }

  // Ensure the circle can toggle stickiness based on input focus
  const circleWrapper = document.querySelector('.sticky-wrapper');
  toggleStickyOnFocus(ELEMENTS.degreeInput, circleWrapper);
  toggleStickyOnFocus(ELEMENTS.qiblatInput, circleWrapper);

  // Add the event listener to the button for fitting the map into a circle
  const toggleMapCircleButton = document.getElementById('toggleMapCircle');
  toggleMapCircleButton.addEventListener('click', toggleMapCircle);

  // Initialize the map rotation slider
  initializeRotationSlider();
};

function initializeMapIfOnline() {
  if (!mapInitialized) {
    loadLeafletResources(function() {
      initializeMap();
      mapInitialized = true;
    });
  }
}

function loadLeafletResources(callback) {
  const leafletCSS = document.createElement('link');
  leafletCSS.rel = 'stylesheet';
  leafletCSS.href = 'https://unpkg.com/leaflet/dist/leaflet.css';
  document.head.appendChild(leafletCSS);

  const geocoderCSS = document.createElement('link');
  geocoderCSS.rel = 'stylesheet';
  geocoderCSS.href = 'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css';
  document.head.appendChild(geocoderCSS);

  loadScript('https://unpkg.com/leaflet/dist/leaflet.js', function() {
    loadScript('https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js', function() {
      loadScript('https://unpkg.com/suncalc/suncalc.js', callback);
    });
  });
}

function checkNetworkStatus() {
  if (navigator.onLine) {
    document.getElementById('map').style.display = 'block';
    initializeMapIfOnline();
  } else {
    document.getElementById('map').style.display = 'none';
  }
}

window.addEventListener('online', checkNetworkStatus);
window.addEventListener('offline', checkNetworkStatus);

function initializeMap() {
  if (!L.Control.Geocoder) {
    console.error('Geocoder library not loaded.');
    return;
  }

  const redIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/supremindset/PAKAR/refs/heads/main/redPin.svg',
    iconSize: [100, 100],
    iconAnchor: [30, 100],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28]
  });

  const yellowIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/supremindset/PAKAR/refs/heads/main/yellowPin.svg',
    iconSize: [100, 100],
    iconAnchor: [30, 100],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28]
  });

  const defaultLocation = [2.8126, 101.5018];
  const map = L.map('map').setView(defaultLocation, 19);

  const esriLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles &copy; <a href="https://www.esri.com/">Esri</a>',
    maxZoom: 23
  }).addTo(map);

  const hereSatelliteLayer = L.tileLayer('https://{s}.aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/satellite.day/{z}/{x}/{y}/256/png8?apiKey=SGBRZo_mNVRWzb2ZckNSjTi2SVZKIgsoW57piYr_uWM&lg=eng', {
    attribution: 'Map data © 2024 HERE',
    subdomains: '1234',
    maxZoom: 22
  });

  const hereNormalDayLayer = L.tileLayer('https://{s}.base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/256/png8?apiKey=SGBRZo_mNVRWzb2ZckNSjTi2SVZKIgsoW57piYr_uWM&lg=eng', {
    attribution: 'Map data © 2024 HERE',
    subdomains: '1234',
    maxZoom: 20
  });

  const openStreetMapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Map data © OpenStreetMap contributors',
    maxZoom: 19
  });

  const baseMaps = {
    "Esri World Imagery": esriLayer,
    "HERE Satellite": hereSatelliteLayer,
    "HERE Normal Day": hereNormalDayLayer,
    "OpenStreetMap": openStreetMapLayer
  };

  L.control.layers(baseMaps).addTo(map);

  const kaabahLatLng = [21.4225, 39.8262];
  const firstPin = L.marker(defaultLocation, {icon: redIcon, draggable: true}).addTo(map);
  const secondPin = L.marker([3.1390, 101.6869], {icon: yellowIcon, draggable: true}).addTo(map);

  map.on('zoomend', function() {
    if (firstPin) {
      map.setView(firstPin.getLatLng(), map.getZoom());
    }
  });

  const initialPath = interpolateGreatCircle(2.8126, 101.5018, kaabahLatLng[0], kaabahLatLng[1], 100);
  const lineToKaabah = L.polyline(initialPath, {color: 'red'}).addTo(map);
  const lineBetweenPins = L.polyline([[2.8126, 101.5018], [3.1390, 101.6869]], {color: 'yellow'}).addTo(map);

  firstPin.on('drag', function() {
    updateBearingAndLines('firstPin');
  });
  secondPin.on('drag', function() {
    updateBearingAndLines('secondPin');
  });

  map.on('click', function(e) {
    secondPin.setLatLng(e.latlng);
    updateBearingAndLines('secondPin');
  });

  map.on('contextmenu', function(e) {
    firstPin.setLatLng(e.latlng);
    updateBearingAndLines('firstPin');
  });

  L.Control.geocoder({
    defaultMarkGeocode: false
  })
  .on('markgeocode', function(e) {
    const bbox = e.geocode.bbox;
    const poly = L.polygon([
      bbox.getSouthEast(),
      bbox.getNorthEast(),
      bbox.getNorthWest(),
      bbox.getSouthWest()
    ]).addTo(map);
    map.fitBounds(poly.getBounds());
    firstPin.setLatLng(e.geocode.center);
    updateBearingAndLines('firstPin');
  })
  .addTo(map);

  function centerMapOnFirstPin() {
    const pinLatLng = firstPin.getLatLng();
    const adjustedLatLng = L.latLng(pinLatLng.lat, pinLatLng.lng - 0.000001); // Adjust longitude slightly
    map.setView(adjustedLatLng, map.getZoom());
  }

  firstPin.on('dragend', centerMapOnFirstPin);
  map.on('zoomend', centerMapOnFirstPin);

  function updateLocation() {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        function(position) {
          const userLat = position.coords.latitude;
          const userLng = position.coords.longitude;
          firstPin.setLatLng([userLat, userLng]);
          centerMapOnFirstPin();
          updateBearingAndLines('firstPin');
        },
        function() {
          alert('Unable to retrieve your location. Please enable location services.');
          firstPin.setLatLng(defaultLocation);
          centerMapOnFirstPin();
          updateBearingAndLines('firstPin');
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    } else {
      alert('Geolocation is not supported by this browser.');
      firstPin.setLatLng(defaultLocation);
      centerMapOnFirstPin();
      updateBearingAndLines('firstPin');
    }
  }

  const updateLocationButton = document.getElementById('updateLocationButton');
  updateLocationButton.addEventListener('click', updateLocation);

  const centerDotButton = document.getElementById('centerDotButton');
  centerDotButton.addEventListener('click', updateLocation);

  const markerTooltipText1Element = document.getElementById('markerTooltipText1');
  const markerTooltipText2Element = document.getElementById('markerTooltipText2');

  updateBearingAndLines = function(changedPin) {
    if (firstPin && secondPin) {
      const firstLatLng = firstPin.getLatLng();
      const secondLatLng = secondPin.getLatLng();

      const pathToKaabah = interpolateGreatCircle(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1], 100);
      lineToKaabah.setLatLngs(pathToKaabah);

      lineBetweenPins.setLatLngs([firstLatLng, secondLatLng]);

      const bearingToKaabah = calculateBearing(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1]);
      const bearingToSecondPin = calculateBearing(firstLatLng.lat, firstLatLng.lng, secondLatLng.lat, secondLatLng.lng);
      
      let sunAzimuth;
      if (changedPin === 'firstPin') {
        sunAzimuth = updateSunAzimuth(firstLatLng);
      } else {
        sunAzimuth = parseFloat(ELEMENTS.degreeInput.value) || 0;
      }

      const shadowEndpoint = calculateShadowEndpoint(firstLatLng, 1000000);
      const currentDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();

      if (isBetweenSunriseSunset(currentDate, firstLatLng.lat, firstLatLng.lng)) {
        if (shadowLine) {
          shadowLine.setLatLngs([firstLatLng, shadowEndpoint]);
          shadowLine.setStyle({ color: 'green' }); // Set the color to green when visible
        } else {
          shadowLine = L.polyline([firstLatLng, shadowEndpoint], { color: 'green' }).addTo(map);
        }
      } else {
        if (shadowLine) {
          shadowLine.setStyle({ color: 'transparent' }); // Set the color to transparent when not visible
        }
      }

      // Update the new tooltip container
          markerTooltipText1Element.innerHTML = `
            Red Pin - Qibla: ${bearingToKaabah.toFixed(2)}°<br/>
            Red Pin - Sun Azimuth: ${sunAzimuth.toFixed(2)}°<br/>
          `;
          
          markerTooltipText2Element.innerHTML = `
            Yellow Pin - Bearing: ${bearingToSecondPin.toFixed(2)}°
          `;
          

          if (!ELEMENTS.dateTimeInput.value) {
            ELEMENTS.qiblatInput.value = bearingToKaabah.toFixed(2);
          }

          if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
            ELEMENTS.degreeInput.value = bearingToSecondPin.toFixed(2);
          } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
            ELEMENTS.degreeInput.value = sunAzimuth.toFixed(2);
          }

          updateArrow(ELEMENTS.blackArrowLine, sunAzimuth);
          updateArrow(ELEMENTS.blackArrowHead, sunAzimuth);

          updateCompassDisplay();
        }
      };

  function isBetweenSunriseSunset(date, latitude, longitude) {
    const sunTimes = SunCalc.getTimes(date, latitude, longitude);
    const currentTime = date.getTime();
    return currentTime >= sunTimes.sunrise.getTime() && currentTime <= sunTimes.sunset.getTime();
  }

  function updateSunAzimuth(position) {
    const selectedDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();
    const sunPosition = SunCalc.getPosition(selectedDate, position.lat, position.lng);
    const azimuth = sunPosition.azimuth * 180 / Math.PI + 180;
    return azimuth;
  }

  ELEMENTS.dateTimeInput.addEventListener('change', function() {
    if (typeof updateBearingAndLines === 'function') {
      updateBearingAndLines('firstPin');
    }
  });

  ELEMENTS.kaedahQiblat.addEventListener('change', () => {
    updateDirectionLabels();
    toggleDateTimeInputVisibility();
    updateBearingAndLines('firstPin');
    if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
      ELEMENTS.degreeInput.placeholder = "Bearing";
      ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
    } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
      ELEMENTS.degreeInput.placeholder = "Azimuth Matahari";
      ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
    }
    updateCompassDisplay();
  });
 }

  function calculateShadowEndpoint(startLatLng, objectHeight) {
    const selectedDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();
    const position = SunCalc.getPosition(selectedDate, startLatLng.lat, startLatLng.lng);

    const azimuth = position.azimuth;
    const altitude = position.altitude;

    const shadowLength = objectHeight / Math.tan(altitude);

    const earthRadius = 6371000;

    const angularDistance = shadowLength / earthRadius;
    const bearing = azimuth;

    const lat1 = toRadians(startLatLng.lat);
    const lon1 = toRadians(startLatLng.lng);

    const lat2 = Math.asin(Math.sin(lat1) * Math.cos(angularDistance) +
        Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(bearing));
    const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(lat1),
        Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(lat2));

    return L.latLng(toDegrees(lat2), toDegrees(lon2));
  }

  const ELEMENTS = {
      circle: document.getElementById('circle'),
      centerLine: document.getElementById('centerLine'),
      arrowLine: document.getElementById('arrowLine'),
      arrowHead: document.getElementById('arrowHead'),
      blackArrowLine: document.getElementById('blackArrowLine'),
      blackArrowHead: document.getElementById('blackArrowHead'),
      kaedahQiblat: document.getElementById('kaedahQiblat'),
      degreeInput: document.getElementById('degreeInput'),
      degreeTooltip: document.getElementById('degreeTooltip'),
      qiblatInput: document.getElementById('qiblatInput'),
      qiblatTooltip: document.getElementById('qiblatTooltip'),
      distanceToKaabah: document.getElementById('distanceToKaabah'),
      dateTimeInput: document.getElementById('dateTimeInput'),
      status: document.getElementById('status')
    };
    
const DISPLAY = {
  BLOCK: 'block',
  NONE: 'none',
};

const QIBLAT_METHODS = {
  BANGUNAN: 'bangunan',
  BAYANG: 'bayang',
};

function toRadians(degrees) {
  return degrees * Math.PI / 180;
}

function toDegrees(radians) {
  return radians * 180 / Math.PI;
}

function calculateBearing(lat1, lon1, lat2, lon2) {
  var lat1Rad = toRadians(lat1);
  var lat2Rad = toRadians(lat2);
  var deltaLonRad = toRadians(lon2 - lon1);

  var y = Math.sin(deltaLonRad) * Math.cos(lat2Rad);
  var x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(deltaLonRad);

  var bearing = Math.atan2(y, x);
  return (toDegrees(bearing) + 360) % 360;
}

function interpolateGreatCircle(lat1, lon1, lat2, lon2, steps) {
  var points = [];
  var startLat = toRadians(lat1);
  var startLon = toRadians(lon1);
  var endLat = toRadians(lat2);
  var endLon = toRadians(lon2);

  var d = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((endLat - startLat) / 2), 2) +
      Math.cos(startLat) * Math.cos(endLat) * Math.pow(Math.sin((endLon - startLon) / 2), 2)));

  for (var i = 0; i <= steps; i++) {
    var f = i / steps;
    var A = Math.sin((1 - f) * d) / Math.sin(d);
    var B = Math.sin(f * d) / Math.sin(d);

    var x = A * Math.cos(startLat) * Math.cos(startLon) + B * Math.cos(endLat) * Math.cos(endLon);
    var y = A * Math.cos(startLat) * Math.sin(startLon) + B * Math.cos(endLat) * Math.sin(endLon);
    var z = A * Math.sin(startLat) + B * Math.sin(endLat);

    var newLat = Math.atan2(z, Math.sqrt(x * x + y * y));
    var newLon = Math.atan2(y, x);

    points.push([toDegrees(newLat), toDegrees(newLon)]);
  }

  return points;
}

const showTooltip = (tooltipElement) => {
  tooltipElement.style.visibility = 'visible';
  tooltipElement.style.opacity = '1';
};

const hideTooltip = (tooltipElement) => {
  tooltipElement.style.visibility = 'hidden';
  tooltipElement.style.opacity = '0';
};

const updateArrow = (element, degree) => {
  element.style.transform = `translateY(-50%) rotate(${degree}deg)`;
};

const updateDirectionLabels = () => {
  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
    document.querySelector('.label-north').textContent = 'S';
    document.querySelector('.label-south').textContent = 'N';
    document.querySelector('.label-east').textContent = 'W';
    document.querySelector('.label-west').textContent = 'E';
  } else {
    document.querySelector('.label-north').textContent = 'N';
    document.querySelector('.label-south').textContent = 'S';
    document.querySelector('.label-east').textContent = 'E';
    document.querySelector('.label-west').textContent = 'W';
  }
};

const updateCompassDisplay = () => {
  const degree = parseFloat(ELEMENTS.degreeInput.value) || 0;
  const inputQiblaDegree = parseFloat(ELEMENTS.qiblatInput.value) || 0;

  let finalQiblatDegree = inputQiblaDegree;

  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
    finalQiblatDegree = (finalQiblatDegree + 180) % 360;
  }

  ELEMENTS.centerLine.style.transform = `translateY(-50%) rotate(${degree}deg)`;
  ELEMENTS.circle.style.transform = `rotate(${90 - degree}deg)`;

  updateArrow(ELEMENTS.blackArrowLine, degree);
  updateArrow(ELEMENTS.blackArrowHead, degree);
  updateArrow(ELEMENTS.arrowLine, finalQiblatDegree || 0);
  updateArrow(ELEMENTS.arrowHead, finalQiblatDegree || 0);

  const angleBetweenLines = calculateAngleBetweenLines(degree, finalQiblatDegree);
  ELEMENTS.angleLabel.textContent = `${angleBetweenLines.toFixed(2)}°`;
};

function calculateAngleBetweenLines(degree1, degree2) {
  let angle = Math.abs(degree2 - degree1);
  if (angle > 180) {
    angle = 360 - angle;
  }
  return angle;
}

const toggleDateTimeInputVisibility = () => {
  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
    ELEMENTS.dateTimeInput.style.display = DISPLAY.BLOCK;
  } else {
    ELEMENTS.dateTimeInput.style.display = DISPLAY.NONE;
  }
};

ELEMENTS.qiblatInput.addEventListener('input', () => {
  updateCompassDisplay();
  resetActivityTimer();
});

ELEMENTS.degreeInput.addEventListener('input', () => {
  updateCompassDisplay();
  resetActivityTimer();
});

// Reset the activity timer and make the circle non-sticky
function resetActivityTimer() {
  clearTimeout(activityTimeout);
  const circleWrapper = document.querySelector('.sticky-wrapper');
  circleWrapper.classList.add('non-sticky');
  activityTimeout = setTimeout(() => {
    circleWrapper.classList.remove('non-sticky');
  }, 1000);
}

const populateDegreeNumbers = () => {
  const radius = ELEMENTS.circle.offsetWidth / 2;
  const offset = 20;
  for (let i = 0; i < 360; i += 10) {
    const degreeNumber = document.createElement('div');
    degreeNumber.className = 'degree-number';
    degreeNumber.textContent = i;

    const angle = i * (Math.PI / 180);
    const x = radius + (radius + offset) * Math.cos(angle);
    const y = radius + (radius + offset) * Math.sin(angle);

    degreeNumber.style.left = `${x}px`;
    degreeNumber.style.top = `${y}px`;
    degreeNumber.style.transform = `translate(-50%, -50%) rotate(${i}deg)`;

    ELEMENTS.circle.appendChild(degreeNumber);
  }
};

function createAngleLabel() {
  const angleLabel = document.createElement('div');
  angleLabel.className = 'angle-label';
  ELEMENTS.arrowLine.appendChild(angleLabel);
  ELEMENTS.angleLabel = angleLabel;
}

// Function to toggle sticky class on the circle
function toggleStickyOnFocus(inputElement, circleWrapper) {
  inputElement.addEventListener('focus', () => {
    circleWrapper.classList.add('non-sticky');
    setTimeout(() => {
      inputElement.scrollIntoView({behavior: 'smooth', block: 'center'});
    }, 300);
  });

  inputElement.addEventListener('blur', () => {
    circleWrapper.classList.remove('non-sticky');
    resetActivityTimer(); // Ensure the timer is reset on blur
  });
}

// Function to toggle the map's circle class
function toggleMapCircle() {
  const mapElement = document.getElementById('map');
  const circleContainer = document.querySelector('.circle-container');

  if (circleContainer.contains(mapElement)) {
    // Move the map outside the circle and restore original styles
    document.querySelector('.map-fieldset').appendChild(mapElement);
    mapElement.style.borderRadius = '0'; // Remove circular shape
    mapElement.style.height = '50vh'; // Original height
    mapElement.style.width = '100%'; // Original width
    mapElement.style.position = 'relative'; // Reset position
    mapElement.style.top = ''; // Reset top
    mapElement.style.left = ''; // Reset left
  } else {
    // Move the map inside the circle and make it circular
    circleContainer.appendChild(mapElement);
    mapElement.classList.add('circle-map'); // Add the class for circular shape
    alignMapWithCircle(); // Align map size with circle
    mapElement.style.borderRadius = '50%'; // Make it circular
    mapElement.style.position = 'absolute'; // Position absolutely
    mapElement.style.top = '0'; // Align at top
    mapElement.style.left = '0'; // Align at left
  }
}

function alignMapWithCircle() {
  const mapElement = document.getElementById('map');
  const circleContainer = document.querySelector('.circle');

  mapElement.style.width = circleContainer.offsetWidth + 'px';
  mapElement.style.height = circleContainer.offsetHeight + 'px';
}

window.addEventListener('resize', alignMapWithCircle); // Ensure alignment when resizing window

populateDegreeNumbers();
updateDirectionLabels();
toggleDateTimeInputVisibility();
createAngleLabel();

if (!isOnline()) {
  updateBearingAndLines = function() {
    console.warn("Offline mode: updateBearingAndLines cannot be executed.");
  };
}

// Function to initialize the map rotation slider
function initializeRotationSlider() {
  const rotationSlider = document.getElementById('rotationSlider');
  const rotationValue = document.getElementById('rotationValue');
  const mapElement = document.getElementById('map');

  rotationSlider.addEventListener('input', (event) => {
    const rotationDegree = event.target.value;
    rotationValue.textContent = `${rotationDegree}°`;
    mapElement.style.transform = `rotate(${rotationDegree}deg)`;
  });
}

function showInstallPromotion() {
  if (deferredPrompt) {
    // Create a custom UI element (e.g., a banner or modal)
    const installBanner = document.createElement('div');
    installBanner.classList.add('install-banner');
    installBanner.textContent = 'Install this app on your device?';

    // Add a click event listener to the banner
    installBanner.addEventListener('click', () => {
      // Show the installation prompt
      deferredPrompt.prompt();
      // Wait for the user's response
      deferredPrompt.userChoice.then((choiceResult) => {
        if (choiceResult.outcome === 'accepted') {
          console.log('User accepted the install prompt');
        } else {
          console.log('User dismissed the install prompt');
        }
        // Remove the install banner
        installBanner.remove();
        // Reset the deferred prompt variable
        deferredPrompt = null;
      });
    });

    // Append the install banner to your UI
    document.body.appendChild(installBanner);
  }
}

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later.
  deferredPrompt = e;
  // Update UI to notify the user they can install the PWA
  showInstallPromotion();
});
  </script>
</body>
</html>
